import{_ as l,r as a,o as s,c as h,a as e,b as r,d as t,e as n}from"./app-pMbPEaNl.js";const E={},p=e("h1",{id:"本周小结-二叉树系列四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-二叉树系列四","aria-hidden":"true"},"#"),r(" 本周小结！（二叉树系列四）")],-1),c=e("blockquote",null,[e("p",null,"这已经是二叉树的第四周总结了，二叉树是非常重要的数据结构，也是面试中的常客，所以有必要一步一步帮助大家彻底掌握二叉树！")],-1),_=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),r(" 周一")],-1),i={href:"https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},d={href:"https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},A=e("p",null,[e("strong",null,"迭代法中，一般一起操作两个树都是使用队列模拟类似层序遍历，同时处理两个树的节点，这种方式最好理解，如果用模拟递归的思路的话，要复杂一些。")],-1),m=e("h2",{id:"周二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周二","aria-hidden":"true"},"#"),r(" 周二")],-1),B=e("p",null,"周二开始讲解一个新的树，二叉搜索树，开始要换一个思路了，如果没有利用好二叉搜索树的特性，就容易把简单题做成了难题了。",-1),u={href:"https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,"大多是二叉搜索树的题目，其实都离不开中序遍历，因为这样就是有序的。",-1),f=e("p",null,"至于迭代法，相信大家看到文章中如此简单的迭代法的时候，都会感动的痛哭流涕。",-1),C=e("h2",{id:"周三",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周三","aria-hidden":"true"},"#"),r(" 周三")],-1),F={href:"https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},b=n("<p>首先在此强调一下二叉搜索树的特性：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>那么我们在验证二叉搜索树的时候，有两个陷阱：</p><ul><li>陷阱一</li></ul><p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>，而是左子树都小于中间节点，右子树都大于中间节点。</p><ul><li>陷阱二</li></ul><p>在一个有序序列求最值的时候，不要定义一个全局遍历，然后遍历序列更新全局变量求最值。因为最值可能就是int 或者 longlong的最小值。</p><p>推荐要通过前一个数值（pre）和后一个数值比较（cur），得出最值。</p><p><strong>在二叉树中通过两个前后指针作比较，会经常用到</strong>。</p>",9),k={href:"https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"周四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周四","aria-hidden":"true"},"#"),r(" 周四")],-1),D={href:"https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html",target:"_blank",rel:"noopener noreferrer"},q={href:"https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},z=e("p",null,[e("strong",null,"要知道二叉搜索树和中序遍历是好朋友！")],-1),N={href:"https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html",target:"_blank",rel:"noopener noreferrer"},V=e("p",null,[e("strong",null,"需要明确：在有序数组求任意两数最小值差等价于相邻两数的最小值差"),r("。")],-1),v=e("p",null,"同样本题也需要用pre节点记录cur节点的前一个节点。（这种写法一定要掌握）",-1),j=e("h2",{id:"周五",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周五","aria-hidden":"true"},"#"),r(" 周五")],-1),I=e("p",null,"此时大家应该知道遇到二叉搜索树，就想是有序数组，那么在二叉搜索树中求二叉搜索树众数就很简单了。",-1),L={href:"https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html",target:"_blank",rel:"noopener noreferrer"},S=e("p",null,"在求众数集合的时候有一个技巧，因为题目中众数是可以有多个的，所以一般的方法需要遍历两遍才能求出众数的集合。",-1),T=e("p",null,[e("strong",null,"但可以遍历一遍就可以求众数集合，使用了适时清空结果集的方法"),r("，这个方法还是很巧妙的。相信仔细读了文章的同学会惊呼其巧妙！")],-1),w=e("p",null,[e("strong",null,"所以大家不要看题目简单了，就不动手做了，我选的题目，一般不会简单到不用动手的程度"),r("。")],-1),y=e("h2",{id:"周六",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周六","aria-hidden":"true"},"#"),r(" 周六")],-1),G={href:"https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",target:"_blank",rel:"noopener noreferrer"},H=n('<p><strong>如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong></p><p>这道题目的看代码比较简单，而且好像也挺好理解的，但是如果把每一个细节理解到位，还是不容易的。</p><p>主要思考如下几点：</p><ul><li>如何从底向上遍历？</li><li>遍历整棵树，还是遍历局部树？</li><li>如何把结果传到根节点的？</li></ul><p>这些问题都需要弄清楚，上来直接看代码的话，是可能想不到这些细节的。</p><p>公共祖先问题，还是有难度的，初学者还是需要慢慢消化！</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',7),J={href:"https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},K={href:"https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html",target:"_blank",rel:"noopener noreferrer"},M={href:"https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},O={href:"https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html",target:"_blank",rel:"noopener noreferrer"},P={href:"https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html",target:"_blank",rel:"noopener noreferrer"},Q={href:"https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html",target:"_blank",rel:"noopener noreferrer"},R=n('<p>现在已经讲过了几种二叉树了，二叉树，二叉平衡树，完全二叉树，二叉搜索树，后面还会有平衡二叉搜索树。 那么一些同学难免会有混乱了，我针对如下三个问题，帮大家在捋顺一遍：</p><ol><li>平衡二叉搜索树是不是二叉搜索树和平衡二叉树的结合？</li></ol><p>是的，是二叉搜索树和平衡二叉树的结合。</p><ol start="2"><li>平衡二叉树与完全二叉树的区别在于底层节点的位置？</li></ol><p>是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。</p><ol start="3"><li>堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？</li></ol><p>堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 <strong>但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树</strong>。</p><p>大家如果每天坚持跟下来，会发现又是充实的一周！[机智]</p>',8);function U(W,X){const o=a("ExternalLinkIcon");return s(),h("div",null,[p,c,_,e("p",null,[r("在"),e("a",i,[r("二叉树：合并两个二叉树"),t(o)]),r("中讲解了如何合并两个二叉树，平时我们都习惯了操作一个二叉树，一起操作两个树可能还有点陌生。")]),e("p",null,[r("其实套路是一样，只不过一起操作两个树的指针，我们之前讲过求 "),e("a",d,[r("二叉树：我对称么？"),t(o)]),r("的时候，已经初步涉及到了 一起遍历两棵二叉树了。")]),A,m,B,e("p",null,[r("学习"),e("a",u,[r("二叉搜索树的特性"),t(o)]),r("，还是比较容易的。")]),g,f,C,e("p",null,[r("了解了二搜索树的特性之后， 开始验证"),e("a",F,[r("一棵二叉树是不是二叉搜索树"),t(o)]),r("。")]),b,e("p",null,[r("本文"),e("a",k,[r("二叉树：我是不是一棵二叉搜索树"),t(o)]),r("中迭代法中为什么没有周一那篇那么简洁了呢，因为本篇是验证二叉搜索树，前提默认它是一棵普通二叉树，所以还是要回归之前老办法。")]),x,e("p",null,[r("了解了"),e("a",D,[r("二叉搜索树"),t(o)]),r("，并且知道"),e("a",q,[r("如何判断二叉搜索树"),t(o)]),r("，本篇就很简单了。")]),z,e("p",null,[r("在"),e("a",N,[r("二叉树：搜索树的最小绝对差"),t(o)]),r("中强调了要利用搜索树的特性，把这道题目想象成在一个有序数组上求两个数最小差值，这就是一道送分题了。")]),V,v,j,I,e("p",null,[r("在"),e("a",L,[r("二叉树：我的众数是多少？"),t(o)]),r("中我给出了如果是普通二叉树，应该如何求众数的集合，然后进一步讲解了二叉搜索树应该如何求众数集合。")]),S,T,w,y,e("p",null,[r("在"),e("a",G,[r("二叉树：公共祖先问题"),t(o)]),r("中，我们开始讲解如何在二叉树中求公共祖先的问题，本来是打算和二叉搜索树一起讲的，但发现篇幅过长，所以先讲二叉树的公共祖先问题。")]),H,e("p",null,[r("本周我们讲了"),e("a",J,[r("如何合并两个二叉树"),t(o)]),r("，了解了如何操作两个二叉树。")]),e("p",null,[r("然后开始另一种树：二叉搜索树，了解"),e("a",K,[r("二叉搜索树的特性"),t(o)]),r("，然后"),e("a",M,[r("判断一棵二叉树是不是二叉搜索树"),t(o)]),r("。")]),e("p",null,[r("了解以上知识之后，就开始利用其特性，做一些二叉搜索树上的题目，"),e("a",O,[r("求最小绝对差"),t(o)]),r("，"),e("a",P,[r("求众数集合"),t(o)]),r("。")]),e("p",null,[r("接下来，开始求二叉树与二叉搜索树的公共祖先问题，单篇篇幅原因，先单独介绍"),e("a",Q,[r("普通二叉树如何求最近公共祖先"),t(o)]),r("。")]),R])}const Z=l(E,[["render",U],["__file","20201017erchashuzhoumozongjie.html.vue"]]);export{Z as default};
