import{_ as r,r as a,o as s,c as l,a as e,b as i,d as t,e as d}from"./app-pMbPEaNl.js";const p={},o=e("h1",{id:"本周小结-动态规划系列二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-动态规划系列二","aria-hidden":"true"},"#"),i(" 本周小结！（动态规划系列二）")],-1),c=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),i(" 周一")],-1),m={href:"https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html",target:"_blank",rel:"noopener noreferrer"},h=d(`<p>我们提供了三种方法，但重点讲解的还是动规，也是需要重点掌握的。</p><p><strong>dp[i][j]定义 ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径</strong>。</p><p>本题在初始化的时候需要点思考了，即：</p><p>dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。</p><p>所以初始化为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for (int i = 0; i &lt; m; i++) dp[i][0] = 1;
for (int j = 0; j &lt; n; j++) dp[0][j] = 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里已经不像之前做过的题目，随便赋个0就行的。</p><p>遍历顺序以及递推公式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for (int i = 1; i &lt; m; i++) {
    for (int j = 1; j &lt; n; j++) {
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113631392-20230310133703294.png" alt="62.不同路径1"></p><h2 id="周二" tabindex="-1"><a class="header-anchor" href="#周二" aria-hidden="true">#</a> 周二</h2>`,11),u={href:"https://programmercarl.com/0063.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html",target:"_blank",rel:"noopener noreferrer"},g=d(`<p>dp[i][j]定义依然是：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。</p><p>本题难点在于初始化，如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0。</p><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114513928-20230310133707783.png" alt="63.不同路径II"></p><p>这里难住了不少同学，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));
for (int i = 0; i &lt; m &amp;&amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
for (int j = 0; j &lt; n &amp;&amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递推公式只要考虑一下障碍，就不赋值了就可以了，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for (int i = 1; i &lt; m; i++) {
    for (int j = 1; j &lt; n; j++) {
        if (obstacleGrid[i][j] == 1) continue;
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>拿示例1来举例如题：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114548983-20230310133711888.png" alt="63.不同路径II1"></p><p>对应的dp table 如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104114610256-20230310133715981.png" alt="63.不同路径II2"></p><h2 id="周三" tabindex="-1"><a class="header-anchor" href="#周三" aria-hidden="true">#</a> 周三</h2>`,13),_={href:"https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html",target:"_blank",rel:"noopener noreferrer"},j=d(`<p>这道题目就有点难度了，题目中dp我也给出了两种方法，但通过两种方法的比较可以看出，对dp数组定义的理解，以及dp数组初始化的重要性。</p><p><strong>dp[i]定义：分拆数字i，可以得到的最大乘积为dp[i]</strong>。</p><p>本题中dp[i]的初始化其实也很有考究，严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。</p><p>拆分0和拆分1的最大乘积是多少？</p><p>这是无解的。</p><p>所以题解里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>vector&lt;int&gt; dp(n + 1);
dp[2] = 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>遍历顺序以及递推公式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>for (int i = 3; i &lt;= n ; i++) {
    for (int j = 1; j &lt; i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>举例当n为10 的时候，dp数组里的数值，如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104173021581-20230310133720552.png" alt="343.整数拆分"></p><p>一些录友可能对为什么没有拆分j没有想清楚。</p><p>其实可以模拟一下哈，拆分j的情况，在遍历j的过程中dp[i - j]其实都计算过了。</p><p>例如 i= 10，j = 5，i-j = 5，如果把j拆分为 2 和 3，其实在j = 2 的时候，i-j= 8 ，拆分i-j的时候就可以拆出来一个3了。</p><p><strong>或者也可以理解j是拆分i的第一个整数</strong>。</p>`,15),b={href:"https://programmercarl.com/0343.%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86.html",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,"对于这种写法，一位录友总结的很好，意思就是：如果递推公式是dp[i-j] * dp[j]，这样就相当于强制把一个数至少拆分成四份。",-1),E=e("p",null,"dp[i-j]至少是两个数的乘积，dp[j]又至少是两个数的乘积，但其实3以下的数，数的本身比任何它的拆分乘积都要大了，所以文章中初始化的时候才要特殊处理。",-1),x=e("h2",{id:"周四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周四","aria-hidden":"true"},"#"),i(" 周四")],-1),B={href:"https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},k=e("p",null,"这道题目还是比较难的，想到用动态规划的方法就很不容易了！",-1),A=e("p",null,[e("strong",null,"dp[i]定义 ：1到i为节点组成的二叉搜索树的个数为dp[i]"),i("。")],-1),C=e("p",null,"递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量",-1),I=e("p",null,"dp数组如何初始化：只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。",-1),q=e("p",null,"n为5时候的dp数组状态如图：",-1),y=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093253987-20230310133724531.png",alt:"96.不同的二叉搜索树3"})],-1),D=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),i(" 总结")],-1),F={href:"https://programmercarl.com/0096.%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html",target:"_blank",rel:"noopener noreferrer"},z=e("p",null,"我现在也陷入了纠结，题目一简单，就会有录友和我反馈说题目太简单了，题目一难，阅读量就特别低。",-1),N=e("p",null,[e("strong",null,"但我还会坚持规划好的路线，难度循序渐进，并以面试经典题目为准，该简单的时候就是简单，同时也不会因为阅读量低就放弃有难度的题目！"),i("。")],-1);function V(G,L){const n=a("ExternalLinkIcon");return s(),l("div",null,[o,c,e("p",null,[e("a",m,[i("动态规划：不同路径"),t(n)]),i("中求从出发点到终点有几种路径，只能向下或者向右移动一步。")]),h,e("p",null,[e("a",u,[i("动态规划：不同路径还不够，要有障碍！"),t(n)]),i("相对于"),e("a",v,[i("动态规划：不同路径"),t(n)]),i("添加了障碍。")]),g,e("p",null,[e("a",_,[i("动态规划：整数拆分，你要怎么拆？"),t(n)]),i("给出一个整数，问有多少种拆分的方法。")]),j,e("p",null,[e("a",b,[i("动态规划：整数拆分，你要怎么拆？"),t(n)]),i("总结里，我也给出了递推公式dp[i] = max(dp[i], dp[i - j] * dp[j])这种写法。")]),f,E,x,e("p",null,[e("a",B,[i("动态规划：不同的二叉搜索树"),t(n)]),i("给出n个不同的节点求能组成多少个不同二叉搜索树。")]),k,A,C,I,q,y,D,e("p",null,[i("本周题目已经开始点难度了，特别是"),e("a",F,[i("动态规划：不同的二叉搜索树"),t(n)]),i("这道题目，明显感觉阅读量很低，可能是因为确实有点难吧。")]),z,N])}const T=r(p,[["render",V],["__file","20210114dongguizhoumozongjie.html.vue"]]);export{T as default};
