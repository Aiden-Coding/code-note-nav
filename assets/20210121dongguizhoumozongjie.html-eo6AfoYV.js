import{_ as d,r,o as a,c as s,a as e,b as i,d as l,e as n}from"./app-pMbPEaNl.js";const o={},p=e("h1",{id:"本周小结-动态规划系列三",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-动态规划系列三","aria-hidden":"true"},"#"),i(" 本周小结！（动态规划系列三）")],-1),c=e("p",null,"本周我们正式开始讲解背包问题，也是动规里非常重要的一类问题。",-1),h=e("p",null,"背包问题其实有很多细节，如果了解个大概，然后也能一气呵成把代码写出来，但稍稍变变花样可能会陷入迷茫了。",-1),u=e("p",null,"开始回顾一下本周的内容吧！",-1),m=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),i(" 周一")],-1),g={href:"https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html",target:"_blank",rel:"noopener noreferrer"},_=n(`<p>首先对于背包的所有问题中，01背包是最最基础的，其他背包也是在01背包的基础上稍作变化。</p><p>所以我才花费这么大精力去讲解01背包。</p><p>关于其他几种常用的背包，大家看这张图就了然于胸了：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210117171307407-20230310133624872.png" alt="416.分割等和子集1"></p><p>本文用动规五部曲详细讲解了01背包的二维dp数组的实现方法，大家其实可以发现最简单的是推导公式了，推导公式估计看一遍就记下来了，但难就难在确定初始化和遍历顺序上。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p><ol start="2"><li>确定递推公式</li></ol><p>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p><ol start="3"><li>dp数组如何初始化</li></ol><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>// 初始化 dp
vector&lt;vector&lt;int&gt;&gt; dp(weight.size() + 1, vector&lt;int&gt;(bagWeight + 1, 0));
for (int j = bagWeight; j &gt;= weight[0]; j--) {
    dp[0][j] = dp[0][j - weight[0]] + value[0];
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>确定遍历顺序</li></ol><p><strong>01背包二维dp数组在遍历顺序上，外层遍历物品 ，内层遍历背包容量 和 外层遍历背包容量 ，内层遍历物品 都是可以的！</strong></p><p>但是先遍历物品更好理解。代码如下：</p><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>// weight数组的大小 就是物品个数
for(int i = 1; i &lt; weight.size(); i++) { // 遍历物品
    for(int j = 0; j &lt;= bagWeight; j++) { // 遍历背包容量
        if (j &lt; weight[i]) dp[i][j] = dp[i - 1][j]; // 这个是为了展现dp数组里元素的变化
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>举例推导dp数组</li></ol><p>背包最大重量为4。</p><p>物品为：</p><table><thead><tr><th></th><th>重量</th><th>价值</th></tr></thead><tbody><tr><td>物品0</td><td>1</td><td>15</td></tr><tr><td>物品1</td><td>3</td><td>20</td></tr><tr><td>物品2</td><td>4</td><td>30</td></tr></tbody></table><p>来看一下对应的dp数组的数值，如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210118163425129-20230310133630224.jpg" alt="动态规划-背包问题4"></p><p>最终结果就是dp[2][4]。</p><h2 id="周二" tabindex="-1"><a class="header-anchor" href="#周二" aria-hidden="true">#</a> 周二</h2>`,23),v={href:"https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html",target:"_blank",rel:"noopener noreferrer"},b=n(`<p>分析一下和二维dp数组有什么区别，在初始化和遍历顺序上又有什么差异？</p><p>最后总结了一道朴实无华的背包面试题。</p><p>要求候选人先实现一个纯二维的01背包，如果写出来了，然后再问为什么两个for循环的嵌套顺序这么写？反过来写行不行？再讲一讲初始化的逻辑。</p><p>然后要求实现一个一维数组的01背包，最后再问，一维数组的01背包，两个for循环的顺序反过来写行不行？为什么？</p><p>这几个问题就可以考察出候选人的算法功底了。</p><p>01背包一维数组分析如下：</p><ol><li>确定dp数组的定义</li></ol><p>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p><ol start="2"><li>一维dp数组的递推公式</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li>一维dp数组如何初始化</li></ol><p>如果物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p><ol start="4"><li>一维dp数组遍历顺序</li></ol><p>代码如下：</p><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>for(int i = 0; i &lt; weight.size(); i++) { // 遍历物品
    for(int j = bagWeight; j &gt;= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>举例推导dp数组</li></ol><p>一维dp，分别用物品0，物品1，物品2 来遍历背包，最终得到结果如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103614769-20230310133634873.png" alt="动态规划-背包问题9"></p><h2 id="周三" tabindex="-1"><a class="header-anchor" href="#周三" aria-hidden="true">#</a> 周三</h2>`,19),E={href:"https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html",target:"_blank",rel:"noopener noreferrer"},f=e("p",null,"只有确定了如下四点，才能把01背包问题套到本题上来。",-1),j=e("ul",null,[e("li",null,"背包的体积为sum / 2"),e("li",null,"背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值"),e("li",null,"背包如何正好装满，说明找到了总和为 sum / 2 的子集。"),e("li",null,"背包中每一个元素是不可重复放入。")],-1),x=e("p",null,"接下来就是一个完整的01背包问题，大家应该可以轻松做出了。",-1),C=e("h2",{id:"周四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周四","aria-hidden":"true"},"#"),i(" 周四")],-1),P={href:"https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html",target:"_blank",rel:"noopener noreferrer"},A={href:"https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html",target:"_blank",rel:"noopener noreferrer"},B=e("p",null,"本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，这样就化解成01背包问题了。",-1),k={href:"https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html",target:"_blank",rel:"noopener noreferrer"},w=e("p",null,"这两道题目是对dp[target]的处理方式不同。这也考验的对dp[i]定义的理解。",-1),D=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),i(" 总结")],-1),z=e("p",null,"总体来说，本周信息量还是比较大的，特别对于对动态规划还不够了解的同学。",-1),I=e("p",null,"但如果坚持下来把，我在文章中列出的每一个问题，都仔细思考，消化为自己的知识，那么进步一定是飞速的。",-1),y=e("p",null,"有的同学可能看了看背包递推公式，上来就能撸它几道题目，然后背包问题就这么过去了，其实这样是很不牢固的。",-1),F=e("p",null,"就像是我们讲解01背包的时候，花了那么大力气才把每一个细节都讲清楚，这里其实是基础，后面的背包问题怎么变，基础比较牢固自然会有自己的一套思考过程。",-1);function N(V,W){const t=r("ExternalLinkIcon");return a(),s("div",null,[p,c,h,u,m,e("p",null,[e("a",g,[i("动态规划：关于01背包问题，你该了解这些！"),l(t)]),i("中，我们开始介绍了背包问题。")]),_,e("p",null,[e("a",v,[i("动态规划：关于01背包问题，你该了解这些！（滚动数组）"),l(t)]),i("中把01背包的一维dp数组（滚动数组）实现详细讲解了一遍。")]),b,e("p",null,[e("a",E,[i("动态规划：416. 分割等和子集"),l(t)]),i("中我们开始用01背包来解决问题。")]),f,j,x,C,e("p",null,[e("a",P,[i("动态规划：1049. 最后一块石头的重量 II"),l(t)]),i("这道题目其实和"),e("a",A,[i("动态规划：416. 分割等和子集"),l(t)]),i("是非常像的。")]),B,e("p",null,[e("a",k,[i("动态规划：416. 分割等和子集"),l(t)]),i("相当于是求背包是否正好装满，而本题是求背包最多能装多少。")]),w,D,z,I,y,F])}const L=d(o,[["render",N],["__file","20210121dongguizhoumozongjie.html.vue"]]);export{L as default};
