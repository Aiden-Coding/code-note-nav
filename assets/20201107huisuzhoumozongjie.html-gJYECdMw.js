import{_ as s,r as a,o as l,c as i,a as e,b as r,d as n,e as o}from"./app-pMbPEaNl.js";const p={},d=e("h1",{id:"本周小结-回溯算法系列二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-回溯算法系列二","aria-hidden":"true"},"#"),r(" 本周小结！（回溯算法系列二）")],-1),c=e("blockquote",null,[e("p",null,"例行每周小结")],-1),h=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),r(" 周一")],-1),m={href:"https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,"不少录友都是看到可以重复选择，就义无反顾的把startIndex去掉了。",-1),E=e("p",null,[e("strong",null,"本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？")],-1),f={href:"https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html",target:"_blank",rel:"noopener noreferrer"},B={href:"https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html",target:"_blank",rel:"noopener noreferrer"},x=e("p",null,[e("strong",null,"注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路，后面我在讲解排列的时候会重点介绍"),r("。")],-1),k=e("p",null,"最后还给出了本题的剪枝优化，如下：",-1),v=e("div",{class:"language-text line-numbers-mode","data-ext":"text"},[e("pre",{class:"language-text"},[e("code",null,`for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
`)]),e("div",{class:"line-numbers","aria-hidden":"true"},[e("div",{class:"line-number"})])],-1),I=e("p",null,"这个优化如果是初学者的话并不容易想到。",-1),A=e("p",null,[e("strong",null,"在求和问题中，排序之后加剪枝是常见的套路！")],-1),C={href:"https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"},z=e("strong",null,"这里这里纠正一下，准确的树形结构如图所示：",-1),q=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201223170730367.png",alt:"39.组合总和"})],-1),D=e("h2",{id:"周二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周二","aria-hidden":"true"},"#"),r(" 周二")],-1),y={href:"https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html",target:"_blank",rel:"noopener noreferrer"},F=o('<p><strong>所以难就难在去重问题上了</strong>。</p><p>这个去重问题，相信做过的录友都知道有多么的晦涩难懂。网上的题解一般就说“去掉重复”，但说不清怎么个去重，代码一甩就完事了。</p><p>为了讲解这个去重问题，<strong>我自创了两个词汇，“树枝去重”和“树层去重”</strong>。</p><p>都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。<strong>没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因</strong>。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123202817973.png" alt="40.组合总和II1"></p><p>我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：</p><ul><li>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</li><li>used[i - 1] == false，说明同一树层candidates[i - 1]使用过</li></ul><p><strong>这块去重的逻辑很抽象，网上搜的题解基本没有能讲清楚的，如果大家之前思考过这个问题或者刷过这道题目，看到这里一定会感觉通透了很多！</strong></p><p>对于去重，其实排列问题也是一样的道理，后面我会讲到。</p><h2 id="周三" tabindex="-1"><a class="header-anchor" href="#周三" aria-hidden="true">#</a> 周三</h2>',10),P={href:"https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html",target:"_blank",rel:"noopener noreferrer"},N=o('<p>我列出如下几个难点：</p><ul><li>切割问题其实类似组合问题</li><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><p>如果想到了<strong>用求解组合问题的思路来解决 切割问题本题就成功一大半了</strong>，接下来就可以对着模板照葫芦画瓢。</p><p><strong>但后序如何模拟切割线，如何终止，如何截取子串，其实都不好想，最后判断回文算是最简单的了</strong>。</p><p>除了这些难点，<strong>本题还有细节，例如：切割过的地方不能重复切割所以递归函数需要传入i + 1</strong>。</p><p>所以本题应该是一个道hard题目了。</p><p><strong>本题的树形结构中，和代码的逻辑有一个小出入，已经判断不是回文的子串就不会进入递归了，纠正如下：</strong></p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203228309.png" alt="131.分割回文串"></p><h2 id="周四" tabindex="-1"><a class="header-anchor" href="#周四" aria-hidden="true">#</a> 周四</h2>',9),V={href:"https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html",target:"_blank",rel:"noopener noreferrer"},j={href:"https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html",target:"_blank",rel:"noopener noreferrer"},L={href:"https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html",target:"_blank",rel:"noopener noreferrer"},S=o(`<p>树形图如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933-20230310133532452.png" alt="93.复原IP地址"></p><p>在本文的树形结构图中，我已经把详细的分析思路都画了出来，相信大家看了之后一定会思路清晰不少！</p><p>本题还可以有一个剪枝，合法ip长度为12，如果s的长度超过了12就不是有效IP地址，直接返回！</p><p>代码如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (s.size() &gt; 12) return result; // 剪枝

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我之前给出的C++代码没有加这个限制，也没有超时，因为在第四段超过长度之后，就会截止了，所以就算给出特别长的字符串，搜索的范围也是有限的（递归只会到第三层），及时就会返回了。</p><h2 id="周五" tabindex="-1"><a class="header-anchor" href="#周五" aria-hidden="true">#</a> 周五</h2>`,8),T={href:"https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html",target:"_blank",rel:"noopener noreferrer"},w=e("strong",null,"在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果",-1),G=o(`<p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/202011232041348.png" alt="78.子集"></p><p>认清这个本质之后，今天的题目就是一道模板题了。</p><p>其实可以不需要加终止条件，因为startIndex &gt;= nums.size()，本层for循环本来也结束了，本来我们就要遍历整棵树。</p><p>有的同学可能担心不写终止条件会不会无限递归？</p><p>并不会，因为每次递归的下一层就是从i+1开始的。</p><p>如果要写终止条件，注意：<code>result.push_back(path);</code>要放在终止条件的上面，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
if (startIndex &gt;= nums.size()) { // 终止条件可以不加
    return;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="周六" tabindex="-1"><a class="header-anchor" href="#周六" aria-hidden="true">#</a> 周六</h2>`,9),H={href:"https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%80%BB%E7%BB%93.html",target:"_blank",rel:"noopener noreferrer"},J=e("p",null,"可能之前大家做过很多哈希表的题目，但是没有串成线，总结篇来帮你串成线，捋顺哈希表的整个脉络。",-1),K=e("p",null,"大家对什么时候各种set与map比较疑惑，想深入了解红黑树，哈希之类的。",-1),M={href:"https://programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"},O=o('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>本周我们依次介绍了组合问题，分割问题以及子集问题，子集问题还没有讲完，下周还会继续。</p><p><strong>我讲解每一种问题，都会和其他问题作对比，做分析，所以只要跟着细心琢磨相信对回溯又有新的认识</strong>。</p><p>最近这两天题目有点难度，刚刚开始学回溯算法的话，按照现在这个每天一题的速度来，确实有点快，学起来吃力非常正常，这些题目都是我当初学了好几个月才整明白的。</p><p><strong>所以大家能跟上的话，已经很优秀了！</strong></p><p>还有一些录友会很关心leetcode上的耗时统计。</p><p>这个是很不准确的，相同的代码多提交几次，大家就知道怎么回事了。</p><p>leetcode上的计时应该是以4ms为单位，有的多提交几次，多个4ms就多击败50%，所以比较夸张，如果程序运行是几百ms的级别，可以看看leetcode上的耗时，因为它的误差10几ms对最终影响不大。</p><p><strong>所以我的题解基本不会写击败百分之多少多少，没啥意义，时间复杂度分析清楚了就可以了</strong>，至于回溯算法不用分析时间复杂度了，都是一样的爆搜，就看谁剪枝厉害了。</p><p>一些录友表示最近回溯算法看的实在是有点懵，回溯算法确实是晦涩难懂，可能视频的话更直观一些，我最近应该会在B站（同名：「代码随想录」）出回溯算法的视频，大家也可以看视频在回顾一波。</p><p><strong>就酱，又是充实的一周，做好本周总结，迎接下一周，冲！</strong></p>',11);function Q(R,U){const t=a("ExternalLinkIcon");return l(),i("div",null,[d,c,h,e("p",null,[r("在"),e("a",m,[r("回溯算法：求组合总和（二）"),n(t)]),r("中讲解的组合总和问题，和以前的组合问题还都不一样。")]),e("p",null,[r("本题和"),e("a",_,[r("回溯算法：求组合问题！"),n(t)]),r("，"),e("a",u,[r("回溯算法：求组合总和！"),n(t)]),r("和区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。")]),g,E,e("p",null,[r("我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如："),e("a",f,[r("回溯算法：求组合问题！"),n(t)]),r("，"),e("a",B,[r("回溯算法：求组合总和！"),n(t)]),r("。")]),e("p",null,[r("如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如："),e("a",b,[r("回溯算法：电话号码的字母组合"),n(t)])]),x,k,v,I,A,e("p",null,[r("在"),e("a",C,[r("回溯算法：求组合总和（二）"),n(t)]),r("第一个树形结构没有画出startIndex的作用，"),z]),q,D,e("p",null,[r("在"),e("a",y,[r("回溯算法：求组合总和（三）"),n(t)]),r("中依旧讲解组合总和问题，本题集合元素会有重复，但要求解集不能包含重复的组合。")]),F,e("p",null,[r("在"),e("a",P,[r("回溯算法：分割回文串"),n(t)]),r("中，我们开始讲解切割问题，虽然最后代码看起来好像是一道模板题，但是从分析到学会套用这个模板，是比较难的。")]),N,e("p",null,[r("如果没有做过"),e("a",V,[r("回溯算法：分割回文串"),n(t)]),r("的话，"),e("a",j,[r("回溯算法：复原IP地址"),n(t)]),r("这道题目应该是比较难的。")]),e("p",null,[r("复原IP照"),e("a",L,[r("回溯算法：分割回文串"),n(t)]),r("就多了一些限制，例如只能分四段，而且还是更改字符串，插入逗点。")]),S,e("p",null,[r("在"),e("a",T,[r("回溯算法：求子集问题！"),n(t)]),r("中讲解了子集问题，"),w,r("。")]),G,e("p",null,[r("早起的哈希表系列没有总结，所以"),e("a",H,[r("哈希表：总结篇！（每逢总结必经典）"),n(t)]),r("如约而至。")]),J,K,e("p",null,[e("strong",null,[r("如果真的只是想清楚什么时候使用各种set与map，不用看那么多，把"),e("a",M,[r("关于哈希表，你该了解这些！"),n(t)]),r("看了就够了")]),r("。")]),O])}const X=s(p,[["render",Q],["__file","20201107huisuzhoumozongjie.html.vue"]]);export{X as default};
