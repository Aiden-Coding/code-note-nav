import{_ as o,r as l,o as s,c as a,a as e,b as r,d as n,e as i}from"./app-pMbPEaNl.js";const h={},c=i(`<h1 id="字符串-总结篇" tabindex="-1"><a class="header-anchor" href="#字符串-总结篇" aria-hidden="true">#</a> 字符串：总结篇</h1><p>其实我们已经学习了十天的字符串了，从字符串的定义到库函数的使用原则，从各种反转到KMP算法，相信大家应该对字符串有比较深刻的认识了。</p><p>那么这次我们来做一个总结。</p><h2 id="什么是字符串" tabindex="-1"><a class="header-anchor" href="#什么是字符串" aria-hidden="true">#</a> 什么是字符串</h2><p>字符串是若干字符组成的有限序列，也可以理解为是一个字符数组，但是很多语言对字符串做了特殊的规定，接下来我来说一说C/C++中的字符串。</p><p>在C语言中，把一个字符串存入一个数组时，也把结束符 &#39;\\0&#39;存入数组，并以此作为该字符串是否结束的标志。</p><p>例如这段代码：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>char a[5] = &quot;asd&quot;;
for (int i = 0; a[i] != &#39;\\0&#39;; i++) {
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用&#39;\\0&#39;来判断是否结束。</p><p>例如这段代码:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>string a = &quot;asd&quot;;
for (int i = 0; i &lt; a.size(); i++) {
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么vector&lt; char &gt; 和 string 又有什么区别呢？</p><p>其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。</p><p>所以想处理字符串，我们还是会定义一个string类型。</p><h2 id="要不要使用库函数" tabindex="-1"><a class="header-anchor" href="#要不要使用库函数" aria-hidden="true">#</a> 要不要使用库函数</h2>`,15),d={href:"https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html",target:"_blank",rel:"noopener noreferrer"},_=e("strong",null,"打基础的时候，不要太迷恋于库函数。",-1),p=e("p",null,"甚至一些同学习惯于调用substr，split，reverse之类的库函数，却不知道其实现原理，也不知道其时间复杂度，这样实现出来的代码，如果在面试现场，面试官问：“分析其时间复杂度”的话，一定会一脸懵逼！",-1),u=e("p",null,[r("所以建议"),e("strong",null,"如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。")],-1),E=e("p",null,[e("strong",null,"如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。")],-1),m=e("h2",{id:"双指针法",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#双指针法","aria-hidden":"true"},"#"),r(" 双指针法")],-1),g={href:"https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html",target:"_blank",rel:"noopener noreferrer"},f=e("strong",null,"双指针法在数组，链表和字符串中很常用。",-1),A={href:"https://programmercarl.com/%E5%89%91%E6%8C%87Offer05.%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.html",target:"_blank",rel:"noopener noreferrer"},B=e("p",null,[e("strong",null,"其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。")],-1),b={href:"https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html",target:"_blank",rel:"noopener noreferrer"},v={href:"https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html",target:"_blank",rel:"noopener noreferrer"},k=e("p",null,"一些同学会使用for循环里调用库函数erase来移除元素，这其实是O(n^2)的操作，因为erase就是O(n)的操作，所以这也是典型的不知道库函数的时间复杂度，上来就用的案例了。",-1),D=e("h2",{id:"反转系列",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#反转系列","aria-hidden":"true"},"#"),r(" 反转系列")],-1),x=e("p",null,"在反转上还可以在加一些玩法，其实考察的是对代码的掌控能力。",-1),C={href:"https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html",target:"_blank",rel:"noopener noreferrer"},K=e("p",null,[r("其实"),e("strong",null,"当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章"),r("。")],-1),M=e("p",null,"只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。",-1),P=e("p",null,"因为要找的也就是每2 * k 区间的起点，这样写程序会高效很多。",-1),F={href:"https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html",target:"_blank",rel:"noopener noreferrer"},I=e("p",null,[r("这道题目通过 "),e("strong",null,"先整体反转再局部反转"),r("，实现了反转字符串里的单词。")],-1),z=e("p",null,"后来发现反转字符串还有一个牛逼的用处，就是达到左旋的效果。",-1),O={href:"https://programmercarl.com/%E5%89%91%E6%8C%87Offer58-II.%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html",target:"_blank",rel:"noopener noreferrer"},S=e("strong",null,"先局部反转再整体反转",-1),q=e("h2",{id:"kmp",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#kmp","aria-hidden":"true"},"#"),r(" KMP")],-1),N=e("p",null,[r("KMP的主要思想是"),e("strong",null,"当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。")],-1),V={href:"https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html",target:"_blank",rel:"noopener noreferrer"},j=e("p",null,"前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。",-1),L=e("p",null,"那么使用KMP可以解决两类经典问题：",-1),T={href:"https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html",target:"_blank",rel:"noopener noreferrer"},y=e("p",null,"再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。",-1),G=e("p",null,"前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。",-1),H=e("p",null,"后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。",-1),J=e("strong",null,"针对前缀表到底要不要减一，这其实是不同KMP实现的方式",-1),Q={href:"https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html",target:"_blank",rel:"noopener noreferrer"},R=e("p",null,[r("其中主要"),e("strong",null,"理解j=next[x]这一步最为关键！")],-1),U=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),r(" 总结")],-1),W=e("p",null,"字符串类类型的题目，往往想法比较简单，但是实现起来并不容易，复杂的字符串题目非常考验对代码的掌控能力。",-1),X=e("p",null,"双指针法是字符串处理的常客。",-1),Y=e("p",null,"KMP算法是字符串查找最重要的算法，但彻底理解KMP并不容易，我们已经写了五篇KMP的文章，不断总结和完善，最终才把KMP讲清楚。",-1),Z=e("p",null,"好了字符串相关的算法知识就介绍到了这里了，明天开始新的征程，大家加油！",-1);function $(ee,re){const t=l("ExternalLinkIcon");return s(),a("div",null,[c,e("p",null,[r("在文章"),e("a",d,[r("344.反转字符串"),n(t)]),r("中强调了"),_]),p,u,E,m,e("p",null,[r("在"),e("a",g,[r("344.反转字符串"),n(t)]),r(" ，我们使用双指针法实现了反转字符串的操作，"),f]),e("p",null,[r("接着在"),e("a",A,[r("字符串：替换空格"),n(t)]),r("，同样还是使用双指针法在时间复杂度O(n)的情况下完成替换空格。")]),B,e("p",null,[r("那么针对数组删除操作的问题，其实在"),e("a",b,[r("27. 移除元素"),n(t)]),r("中就已经提到了使用双指针法进行移除操作。")]),e("p",null,[r("同样的道理在"),e("a",v,[r("151.翻转字符串里的单词"),n(t)]),r("中我们使用O(n)的时间复杂度，完成了删除冗余空格。")]),k,D,x,e("p",null,[e("a",C,[r("541. 反转字符串II"),n(t)]),r("中，一些同学可能为了处理逻辑：每隔2k个字符的前k的字符，写了一堆逻辑代码或者再搞一个计数器，来统计2k，再统计前k个字符。")]),K,M,P,e("p",null,[r("在"),e("a",F,[r("151.翻转字符串里的单词"),n(t)]),r("中要求翻转字符串里的单词，这道题目可以说是综合考察了字符串的多种操作。是考察字符串的好题。")]),I,z,e("p",null,[r("在"),e("a",O,[r("字符串：反转个字符串还有这个用处？"),n(t)]),r("中，我们通过"),S,r("达到了左旋的效果。")]),q,N,e("p",null,[r("KMP的精髓所在就是前缀表，在"),e("a",V,[r("KMP精讲"),n(t)]),r("中提到了，什么是KMP，什么是前缀表，以及为什么要用前缀表。")]),j,L,e("ol",null,[e("li",null,[r("匹配问题："),e("a",T,[r("28. 实现 strStr()"),n(t)])]),e("li",null,[r("重复子串问题："),e("a",w,[r("459.重复的子字符串"),n(t)])])]),y,G,H,e("p",null,[r("然后"),J,r("，我们在"),e("a",Q,[r("KMP精讲"),n(t)]),r("中针对之前两个问题，分别给出了两个不同版本的的KMP实现。")]),R,U,W,X,Y,Z])}const ne=o(h,[["render",$],["__file","zifuchuanzongjie.html.vue"]]);export{ne as default};
