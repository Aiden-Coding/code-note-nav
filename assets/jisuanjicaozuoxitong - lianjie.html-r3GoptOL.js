import{_ as a,o as n,c as s,e}from"./app-pMbPEaNl.js";const i="/code-note-nav/assets/b396d726-b75f-4a32-89a2-03a7b6e19f6f-LnpqZg96.jpg",l="/code-note-nav/assets/47d98583-8bb0-45cc-812d-47eefa0a4a40-Mpwg6z9h.jpg",t="/code-note-nav/assets/76dc7769-1aac-4888-9bea-064f1caa8e77-OH-9kfTU.jpg",c={},o=e(`<h1 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h1><h2 id="编译系统" tabindex="-1"><a class="header-anchor" href="#编译系统" aria-hidden="true">#</a> 编译系统</h2><p>以下是一个 hello.c 程序：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;hello, world\\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Unix 系统上，由编译器把源文件转换为目标文件。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>gcc <span class="token parameter variable">-o</span> hello hello.c
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个过程大致如下：</p><p><img src="`+i+'" alt="image-20220324093855618"></p><ul><li>预处理阶段：处理以 # 开头的预处理命令；</li><li>编译阶段：翻译成汇编文件；</li><li>汇编阶段：将汇编文件翻译成可重定位目标文件；</li><li>链接阶段：将可重定位目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。</li></ul><h2 id="静态链接" tabindex="-1"><a class="header-anchor" href="#静态链接" aria-hidden="true">#</a> 静态链接</h2><p>静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务：</p><ul><li>符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。</li><li>重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。</li></ul><p><img src="'+l+'" alt="image-20220324093855618"></p><h2 id="目标文件" tabindex="-1"><a class="header-anchor" href="#目标文件" aria-hidden="true">#</a> 目标文件</h2><ul><li>可执行目标文件：可以直接在内存中执行；</li><li>可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；</li><li>共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；</li></ul><h2 id="动态链接" tabindex="-1"><a class="header-anchor" href="#动态链接" aria-hidden="true">#</a> 动态链接</h2><p>静态库有以下两个问题：</p><ul><li>当静态库更新时那么整个程序都要重新进行链接；</li><li>对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。</li></ul><p>共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：</p><ul><li>在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；</li><li>在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。</li></ul><p><img src="'+t+'" alt="image-20220324093855618"></p>',21),p=[o];function d(r,u){return n(),s("div",null,p)}const m=a(c,[["render",d],["__file","jisuanjicaozuoxitong - lianjie.html.vue"]]);export{m as default};
