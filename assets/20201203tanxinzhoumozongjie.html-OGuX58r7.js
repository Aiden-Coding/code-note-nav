import{_ as s,r as l,o as a,c,a as e,b as t,d as o,e as r}from"./app-pMbPEaNl.js";const h={},i=e("h1",{id:"本周小结-贪心算法系列二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-贪心算法系列二","aria-hidden":"true"},"#"),t(" 本周小结！（贪心算法系列二）")],-1),p=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),t(" 周一")],-1),d=e("p",null,"一说到股票问题，一般都会想到动态规划，其实有时候贪心更有效！",-1),_={href:"https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html",target:"_blank",rel:"noopener noreferrer"},m=e("p",null,[e("strong",null,"这道题目理解利润拆分是关键点！"),t(" 不要整块的去看，而是把整体利润拆为每天的利润，就很容易想到贪心了。")],-1),u=e("p",null,[e("strong",null,"局部最优：只收集每天的正利润，全局最优：得到最大利润"),t("。")],-1),g=e("p",null,"如果正利润连续上了，相当于连续持有股票，而本题并不需要计算具体的区间。",-1),E=e("p",null,"如图：",-1),f=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/2020112917480858.png",alt:"122.买卖股票的最佳时机II"})],-1),B=e("h2",{id:"周二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周二","aria-hidden":"true"},"#"),t(" 周二")],-1),I={href:"https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html",target:"_blank",rel:"noopener noreferrer"},k=r('<p>本题贪心的关键是：<strong>不用拘泥于每次究竟跳几步，而是看覆盖范围，覆盖范围内一定是可以跳过来的，不用管是怎么跳的</strong>。</p><p><strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p><p>贪心算法局部最优解：移动下标每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</p><p>如果覆盖范围覆盖到了终点，就表示一定可以跳过去。</p><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201124154758229.png" alt="55.跳跃游戏"></p><h2 id="周三" tabindex="-1"><a class="header-anchor" href="#周三" aria-hidden="true">#</a> 周三</h2>',7),x={href:"https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html",target:"_blank",rel:"noopener noreferrer"},b=e("p",null,[t("本题解题关键在于："),e("strong",null,"以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点"),t("。")],-1),A=e("p",null,"那么局部最优：求当前这步的最大覆盖，那么尽可能多走，到达覆盖范围的终点，只需要一步。整体最优：达到终点，步数最少。",-1),C=e("p",null,"如图：",-1),q=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201201232309103-20230310133110942.png",alt:"45.跳跃游戏II"})],-1),y=e("p",null,[t("注意："),e("strong",null,"图中的移动下标是到当前这步覆盖的最远距离（下标2的位置），此时没有到终点，只能增加第二步来扩大覆盖范围"),t("。")],-1),F={href:"https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html",target:"_blank",rel:"noopener noreferrer"},z=e("p",null,"其实本质都是超过当前覆盖范围，步数就加一，但版本一需要考虑当前覆盖最远距离下标是不是数组终点的情况。",-1),K=e("p",null,"而版本二就比较统一的，超过范围，步数就加一，但在移动下标的范围了做了文章。",-1),N=e("p",null,[t("即如果覆盖最远距离下标是倒数第二点：直接加一就行，默认一定可以到终点。如图： "),e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201201232445286-20230310133115650.png",alt:"45.跳跃游戏II2"})],-1),V=e("p",null,[t("如果覆盖最远距离下标不是倒数第二点，说明本次覆盖已经到终点了。如图： "),e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201201232338693-20230310133120115.png",alt:"45.跳跃游戏II1"})],-1),v=e("p",null,"有的录友认为版本一好理解，有的录友认为版本二好理解，其实掌握一种就可以了，也不用非要比拼一下代码的简洁性，简洁程度都差不多了。",-1),D=e("p",null,"我个人倾向于版本一的写法，思路清晰一点，版本二会有点绕。",-1),j=e("h2",{id:"周四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周四","aria-hidden":"true"},"#"),t(" 周四")],-1),L={href:"https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"},$=r('<p><strong>这里其实用了两次贪心！</strong></p><p>第一次贪心：局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</p><p>处理之后，如果K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。</p><p>第二次贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。</p><p>例外一位录友留言给出一个很好的建议，因为文中是使用快排，仔细看题，<strong>题目中限定了数据范围是正负一百，所以可以使用桶排序</strong>，这样时间复杂度就可以优化为$O(n)$了。但可能代码要复杂一些了。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>大家会发现本周的代码其实都简单，但思路却很巧妙，并不容易写出来。</p><p>如果是第一次接触的话，其实很难想出来，就是接触过之后就会了，所以大家不用感觉自己想不出来而烦躁。</p><p>相信此时大家现在对贪心算法又有一个新的认识了，加油💪</p>',9);function O(S,T){const n=l("ExternalLinkIcon");return a(),c("div",null,[i,p,d,e("p",null,[t("在"),e("a",_,[t("贪心算法：买卖股票的最佳时机II"),o(n)]),t("中，讲到只能多次买卖一支股票，如何获取最大利润。")]),m,u,g,E,f,B,e("p",null,[t("在"),e("a",I,[t("贪心算法：跳跃游戏"),o(n)]),t("中是给你一个数组看能否跳到终点。")]),k,e("p",null,[t("这道题目："),e("a",x,[t("贪心算法：跳跃游戏II"),o(n)]),t("可就有点难了。")]),b,A,C,q,y,e("p",null,[t("在"),e("a",F,[t("贪心算法：跳跃游戏II"),o(n)]),t("中我给出了两个版本的代码。")]),z,K,N,V,v,D,j,e("p",null,[t("这道题目："),e("a",L,[t("贪心算法：K次取反后最大化的数组和"),o(n)]),t("就比较简单了，用简单题来讲一讲贪心的思想。")]),$])}const G=s(h,[["render",O],["__file","20201203tanxinzhoumozongjie.html.vue"]]);export{G as default};
