import{_ as d,r as t,o as a,c as p,a as i,b as e,d as l,e as n}from"./app-pMbPEaNl.js";const s={},o=i("h1",{id:"本周小结-动态规划系列七",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#本周小结-动态规划系列七","aria-hidden":"true"},"#"),e(" 本周小结！（动态规划系列七）")],-1),c=i("p",null,"本周的主题就是股票系列，来一起回顾一下吧",-1),m=i("h2",{id:"周一",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),e(" 周一")],-1),E={href:"https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html",target:"_blank",rel:"noopener noreferrer"},g=n(`<p>重点在于递推公式的不同。</p><p>在回顾一下dp数组的含义：</p><ul><li>dp[i][0] 表示第i天持有股票所得现金。</li><li>dp[i][1] 表示第i天不持有股票所得最多现金</li></ul><p>递推公式：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,5),u={href:"https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html",target:"_blank",rel:"noopener noreferrer"},v=n(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>这正是因为本题的股票可以买卖多次！</strong> 所以买入股票的时候，可能会有之前买卖的利润即：dp[i - 1][1]，所以dp[i - 1][1] - prices[i]。</p><h2 id="周二" tabindex="-1"><a class="header-anchor" href="#周二" aria-hidden="true">#</a> 周二</h2>`,3),B={href:"https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html",target:"_blank",rel:"noopener noreferrer"},_=n(`<p><strong>这意味着可以买卖一次，可以买卖两次，也可以不买卖</strong>。</p><ol><li>确定dp数组以及下标的含义</li></ol><p>一天一共就有五个状态，</p><ol start="0"><li>没有操作</li><li>第一次买入</li><li>第一次卖出</li><li>第二次买入</li><li>第二次卖出</li></ol><p><strong>dp[i][j]中 i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示第i天状态j所剩最大现金</strong>。</p><ol start="2"><li>确定递推公式</li></ol><p>需要注意：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);
dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2]);
dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>dp数组如何初始化</li></ol><p>dp[0][0] = 0; dp[0][1] = -prices[0]; dp[0][2] = 0; dp[0][3] = -prices[0]; dp[0][4] = 0;</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以输入[1,2,3,4,5]为例</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201228181724295.png" alt="123.买卖股票的最佳时机III"></p><p>可以看到红色框为最后两次卖出的状态。</p><p>现在最大的时候一定是卖出的状态，而两次卖出的状态现金最大一定是最后一次卖出。</p><p>所以最终最大利润是dp[4][4]</p><h2 id="周三" tabindex="-1"><a class="header-anchor" href="#周三" aria-hidden="true">#</a> 周三</h2>`,19),A={href:"https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html",target:"_blank",rel:"noopener noreferrer"},x=n(`<ol><li>确定dp数组以及下标的含义</li></ol><p>使用二维数组 dp[i][j] ：第i天的状态为j，所剩下的最大现金是dp[i][j]</p><p>j的状态表示为：</p><ul><li>0 表示不操作</li><li>1 第一次买入</li><li>2 第一次卖出</li><li>3 第二次买入</li><li>4 第二次卖出</li><li>.....</li></ul><p><strong>除了0以外，偶数就是卖出，奇数就是买入</strong>。</p><ol start="2"><li>确定递推公式</li></ol><p>还要强调一下：dp[i][1]，<strong>表示的是第i天，买入股票的状态，并不是说一定要第i天买入股票，这是很多同学容易陷入的误区</strong>。</p><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>for (int j = 0; j &lt; 2 * k - 1; j += 2) {
    dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
    dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),f={href:"https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII.html",target:"_blank",rel:"noopener noreferrer"},I=n(`<ol start="3"><li>dp数组如何初始化</li></ol><p><strong>dp[0][j]当j为奇数的时候都初始化为 -prices[0]</strong></p><p>代码如下：</p><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>for (int j = 1; j &lt; 2 * k; j += 2) {
    dp[0][j] = -prices[0];
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>在初始化的地方同样要类比j为奇数是买、偶数是卖的状态</strong>。</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式其实已经可以看出，一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以输入[1,2,3,4,5]，k=2为例。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201229100358221-20230310133805763.png" alt="188.买卖股票的最佳时机IV"></p><p>最后一次卖出，一定是利润最大的，dp[prices.size() - 1][2 * k]即红色部分就是最后求解。</p><h2 id="周四" tabindex="-1"><a class="header-anchor" href="#周四" aria-hidden="true">#</a> 周四</h2>`,12),C={href:"https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html",target:"_blank",rel:"noopener noreferrer"},j={href:"https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html",target:"_blank",rel:"noopener noreferrer"},k=n(`<p><strong>本题则需要第三个状态：不持有股票（冷冻期）的最多现金</strong>。</p><p>动规五部曲，分析如下：</p><ol><li>确定dp数组以及下标的含义</li></ol><p><strong>dp[i][j]，第i天状态为j，所剩的最多现金为dp[i][j]</strong>。</p><p>j的状态为：</p><ul><li>0：持有股票后的最多现金</li><li>1：不持有股票（能购买）的最多现金</li><li>2：不持有股票（冷冻期）的最多现金</li></ul><ol start="2"><li>确定递推公式</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][2]);
dp[i][2] = dp[i - 1][0] + prices[i];
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>dp数组如何初始化</li></ol><p>可以统一都初始为0了。</p><p>代码如下：</p><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(3, 0));
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>初始化其实很有讲究，很多同学可能是稀里糊涂的全都初始化0，反正就可以通过，但没有想清楚，为什么都初始化为0</strong>。</p><ol start="4"><li>确定遍历顺序</li></ol><p>从递归公式上可以看出，dp[i] 依赖于 dp[i-1]，所以是从前向后遍历。</p><ol start="5"><li>举例推导dp数组</li></ol><p>以 [1,2,3,0,2] 为例，dp数组如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201229163725348.png" alt="309.最佳买卖股票时机含冷冻期"></p><p>最后两个状态 不持有股票（能购买） 和 不持有股票（冷冻期）都有可能最后结果，取最大的。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>下周还会有一篇股票系列的文章，<strong>股票系列后面我也会单独写一篇总结，来高度概括一下，这样大家会对股票问题就有一个整体性的理解了</strong>。</p>`,21);function D(P,V){const r=t("ExternalLinkIcon");return a(),p("div",null,[o,c,m,i("p",null,[i("a",E,[e("动态规划：买卖股票的最佳时机II"),l(r)]),e("中股票可以买卖多次了！")]),i("p",null,[e("这也是和"),i("a",h,[e("121. 买卖股票的最佳时机"),l(r)]),e("的唯一区别（注意只有一只股票，所以再次购买前要出售掉之前的股票）")]),g,i("p",null,[e("大家可以发现本题和"),i("a",u,[e("121. 买卖股票的最佳时机"),l(r)]),e("的代码几乎一样，唯一的区别在：")]),v,i("p",null,[i("a",B,[e("动态规划：买卖股票的最佳时机III"),l(r)]),e("中最多只能完成两笔交易。")]),_,i("p",null,[i("a",A,[e("动态规划：买卖股票的最佳时机IV"),l(r)]),e("最多可以完成 k 笔交易。")]),i("p",null,[e("相对于上一道"),i("a",b,[e("动态规划：123.买卖股票的最佳时机III"),l(r)]),e("，本题需要通过前两次的交易，来类比前k次的交易")]),x,i("p",null,[i("strong",null,[e("本题和"),i("a",f,[e("动态规划：123.买卖股票的最佳时机III"),l(r)]),e("最大的区别就是这里要类比j为奇数是买，偶数是卖的状态")]),e("。")]),I,i("p",null,[i("a",C,[e("动态规划：最佳买卖股票时机含冷冻期"),l(r)]),e("尽可能地完成更多的交易（多次买卖一支股票），但有冷冻期，冷冻期为1天")]),i("p",null,[e("相对于"),i("a",j,[e("动态规划：122.买卖股票的最佳时机II"),l(r)]),e("，本题加上了一个冷冻期")]),k])}const F=d(s,[["render",D],["__file","20210304dongguizhoumozongjie.html.vue"]]);export{F as default};
