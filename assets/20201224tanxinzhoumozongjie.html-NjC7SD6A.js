import{_ as l,r as s,o as a,c as o,a as e,b as n,d as t,e as r}from"./app-pMbPEaNl.js";const c={},d=e("h1",{id:"本周小结-贪心算法系列四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-贪心算法系列四","aria-hidden":"true"},"#"),n(" 本周小结！（贪心算法系列四）")],-1),h=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),n(" 周一")],-1),p={href:"https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html",target:"_blank",rel:"noopener noreferrer"},_=e("p",null,"按照左边界进行排序后，如果气球重叠了，重叠气球中右边边界的最小值 之前的区间一定需要一个弓箭",-1),m=e("p",null,"如图：",-1),u=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201123101929791-20230310133845522.png",alt:"452.用最少数量的箭引爆气球"})],-1),v=e("p",null,"模拟射气球的过程，很多同学真的要去模拟了，实时把气球从数组中移走，这么写的话就复杂了，从前向后遍历重复的只要跳过就可以的。",-1),E=e("h2",{id:"周二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周二","aria-hidden":"true"},"#"),n(" 周二")],-1),b={href:"https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html",target:"_blank",rel:"noopener noreferrer"},g=e("p",null,"我来按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数了。",-1),f=e("p",null,"如图：",-1),B=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201221201553618.png",alt:"435.无重叠区间"})],-1),A={href:"https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html",target:"_blank",rel:"noopener noreferrer"},C=e("p",null,"弓箭的数量就相当于是非交叉区间的数量，只要把弓箭那道题目代码里射爆气球的判断条件加个等号（认为[0，1][1，2]不是相邻区间），然后用总区间数减去弓箭数量 就是要移除的区间数量了。",-1),k={href:"https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html",target:"_blank",rel:"noopener noreferrer"},x=r(`<p>修改后的C++代码如下：</p><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>class Solution {
public:
    // 按照区间左边界从大到小排序
    static bool cmp (const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {
        return a[0] &lt; b[0];
    }
    int eraseOverlapIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if (intervals.size() == 0) return 0;
        sort(intervals.begin(), intervals.end(), cmp);

        int result = 1;
        for (int i = 1; i &lt; intervals.size(); i++) {
            if (intervals[i][0] &gt;= intervals[i - 1][1]) { // 需要要把&gt; 改成 &gt;= 就可以了
                result++; // 需要一支箭
            }
            else {
                intervals[i][1] = min(intervals[i - 1][1], intervals[i][1]); // 更新重叠气球最小右边界
            }
        }
        return intervals.size() - result;
    }
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="周三" tabindex="-1"><a class="header-anchor" href="#周三" aria-hidden="true">#</a> 周三</h2>`,3),z={href:"https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html",target:"_blank",rel:"noopener noreferrer"},D=r('<p>这道题目leetcode上标的是贪心，其实我不认为是贪心，因为没感受到局部最优和全局最优的关系。</p><p>但不影响这是一道好题，思路很不错，<strong>通过字符出现最远距离取并集的方法，把出现过的字符都圈到一个区间里</strong>。</p><p>解题过程分如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><p>如图：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201222191924417-20230310133855435.png" alt="763.划分字母区间"></p><h2 id="周四" tabindex="-1"><a class="header-anchor" href="#周四" aria-hidden="true">#</a> 周四</h2>',7),P={href:"https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html",target:"_blank",rel:"noopener noreferrer"},F=e("p",null,"相信如果录友们前几天区间问题的题目认真练习了，今天题目就应该算简单一些了。",-1),q=e("p",null,"按照左边界排序，排序之后局部最优：每次合并都取最大的右边界，这样就可以合并更多的区间了，整体最优：合并所有重叠的区间。",-1),y=e("p",null,"具体操作：按照左边界从小到大排序之后，如果 intervals[i][0] < intervals[i - 1][1] 即intervals[i]左边界 < intervals[i - 1]右边界，则一定有重复，因为intervals[i]的左边界一定是大于等于intervals[i - 1]的左边界。",-1),N=e("p",null,"如图：",-1),V=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201223200632791-20230310133859587.png",alt:"56.合并区间"})],-1),I=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),n(" 总结")],-1),j=e("p",null,"本周的主题就是用贪心算法来解决区间问题，经过本周的学习，大家应该对区间的各种合并分割有一定程度的了解了。",-1),L=e("p",null,"其实很多区间的合并操作看起来都是常识，其实贪心算法有时候就是常识，但也别小看了贪心算法。",-1),S={href:"https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html",target:"_blank",rel:"noopener noreferrer"},O=e("p",null,"所以还是要多看多做多练习！",-1),T=e("p",null,[e("strong",null,"「代码随想录」里总结的都是经典题目，大家跟着练就节省了不少选择题目的时间了"),n("。")],-1);function w(G,H){const i=s("ExternalLinkIcon");return a(),o("div",null,[d,h,e("p",null,[n("在"),e("a",p,[n("贪心算法：用最少数量的箭引爆气球"),t(i)]),n("中，我们开始讲解了重叠区间问题，用最少的弓箭射爆所有气球，其本质就是找到最大的重叠区间。")]),_,m,u,v,E,e("p",null,[n("在"),e("a",b,[n("贪心算法：无重叠区间"),t(i)]),n("中要去掉最少的区间，来让所有区间没有重叠。")]),g,f,B,e("p",null,[n("细心的同学就发现了，此题和 "),e("a",A,[n("贪心算法：用最少数量的箭引爆气球"),t(i)]),n("非常像。")]),C,e("p",null,[n("把"),e("a",k,[n("贪心算法：用最少数量的箭引爆气球"),t(i)]),n("代码稍做修改，就可以AC本题。")]),x,e("p",null,[e("a",z,[n("贪心算法：划分字母区间"),t(i)]),n("中我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。")]),D,e("p",null,[e("a",P,[n("贪心算法：合并区间"),t(i)]),n("中要合并所有重叠的区间。")]),F,q,y,N,V,I,j,L,e("p",null,[n("在"),e("a",S,[n("贪心算法：合并区间"),t(i)]),n("中就说过，对于贪心算法，很多同学都是：「如果能凭常识直接做出来，就会感觉不到自己用了贪心, 一旦第一直觉想不出来, 可能就一直想不出来了」。")]),O,T])}const K=l(c,[["render",w],["__file","20201224tanxinzhoumozongjie.html.vue"]]);export{K as default};
