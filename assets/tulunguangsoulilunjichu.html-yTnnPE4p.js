import{_ as p,r as i,o,c,a as s,b as n,d as e,e as t}from"./app-pMbPEaNl.js";const l={},u=s("h1",{id:"广度优先搜索理论基础",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#广度优先搜索理论基础","aria-hidden":"true"},"#"),n(" 广度优先搜索理论基础")],-1),r={href:"https://programmercarl.com/%E5%9B%BE%E8%AE%BA%E6%B7%B1%E6%90%9C%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"},d=t(`<p>广搜（bfs）是一圈一圈的搜索过程，和深搜（dfs）是一条路跑到黑然后再回溯。</p><h2 id="广搜的使用场景" tabindex="-1"><a class="header-anchor" href="#广搜的使用场景" aria-hidden="true">#</a> 广搜的使用场景</h2><p>广搜的搜索方式就适合于解决两个点之间的最短路径问题。</p><p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p><p>当然，也有一些问题是广搜 和 深搜都可以解决的，例如岛屿问题，<strong>这类问题的特征就是不涉及具体的遍历方式，只要能把相邻且相同属性的节点标记上就行</strong>。 （我们会在具体题目讲解中详细来说）</p><h2 id="广搜的过程" tabindex="-1"><a class="header-anchor" href="#广搜的过程" aria-hidden="true">#</a> 广搜的过程</h2><p>上面我们提过，BFS是一圈一圈的搜索过程，但具体是怎么一圈一圈来搜呢。</p><p>我们用一个方格地图，假如每次搜索的方向为 上下左右（不包含斜上方），那么给出一个start起始位置，那么BFS就是从四个方向走出第一步。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220825104505.png" alt="图一"></p><p>如果加上一个end终止位置，那么使用BFS的搜索过程如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220825102653.png" alt="图二"></p><p>我们从图中可以看出，从start起点开始，是一圈一圈，向外搜索，方格编号1为第一步遍历的节点，方格编号2为第二步遍历的节点，第四步的时候我们找到终止点end。</p><p>正是因为BFS一圈一圈的遍历方式，所以一旦遇到终止点，那么一定是一条最短路径。</p><p>而且地图还可以有障碍，如图所示：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220825103900.png" alt="图三"></p><p>在第五步，第六步 我只把关键的节点染色了，其他方向周边没有去染色，大家只要关注关键地方染色的逻辑就可以。</p><p>从图中可以看出，如果添加了障碍，我们是第六步才能走到end终点。</p><p>只要BFS只要搜到终点一定是一条最短路径，大家可以参考上面的图，自己再去模拟一下。</p><h2 id="代码框架" tabindex="-1"><a class="header-anchor" href="#代码框架" aria-hidden="true">#</a> 代码框架</h2><p>大家应该好奇，这一圈一圈的搜索过程是怎么做到的，是放在什么容器里，才能这样去遍历。</p><p>很多网上的资料都是直接说用队列来实现。</p><p>其实，我们仅仅需要一个容器，能保存我们要遍历过的元素就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p><p><strong>用队列的话，就是保证每一圈都是一个方向去转，例如统一顺时针或者逆时针</strong>。</p><p>因为队列是先进先出，加入元素和弹出元素的顺序是没有改变的。</p><p><strong>如果用栈的话，就是第一圈顺时针遍历，第二圈逆时针遍历，第三圈有顺时针遍历</strong>。</p><p>因为栈是先进后出，加入元素和弹出元素的顺序改变了。</p><p>那么广搜需要注意 转圈搜索的顺序吗？ 不需要！</p><p>所以用队列，还是用栈都是可以的，但大家都习惯用队列了，<strong>所以下面的讲解用我也用队列来讲，只不过要给大家说清楚，并不是非要用队列，用栈也可以</strong>。</p><p>下面给出广搜代码模板，该模板针对的就是，上面的四方格的地图： （详细注释）</p><div class="language-CPP line-numbers-mode" data-ext="CPP"><pre class="language-CPP"><code>int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x, int y) {
    queue&lt;pair&lt;int, int&gt;&gt; que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair&lt;int ,int&gt; cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i &lt; 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx &lt; 0 || nextx &gt;= grid.size() || nexty &lt; 0 || nexty &gt;= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,30),k={href:"https://leetcode.cn/problems/number-of-islands/solution/by-carlsun-2-n72a/",target:"_blank",rel:"noopener noreferrer"},v=t(`<p>即：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (!visited[nextx][nexty]) { // 如果节点没被访问过
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>改为</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (!visited[nextx][nexty] &amp;&amp; grid[nextx][nexty] == &#39;1&#39;) { // 如果节点没被访问过且节点是可遍历的

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,4),m={href:"https://leetcode.cn/problems/number-of-islands/solution/by-carlsun-2-n72a/",target:"_blank",rel:"noopener noreferrer"},b=s("h2",{id:"总结",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),n(" 总结")],-1),h=s("p",null,"当然广搜还有很多细节需要注意的地方，后面我会针对广搜的题目还做针对性的讲解，因为在理论篇讲太多细节，可能会让刚学广搜的录友们越看越懵，所以细节方面针对具体题目在做讲解。",-1),x=s("p",null,"本篇我们重点讲解了广搜的使用场景，广搜的过程以及广搜的代码框架。",-1),g={href:"https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html",target:"_blank",rel:"noopener noreferrer"},y=t(`<p>这次则从图论的角度上再详细讲解一次广度优先遍历。</p><p>相信看完本篇，大家会对广搜有一个基础性的认识，后面再来做对应的题目就会得心应手一些。</p><h2 id="其他语言版本" tabindex="-1"><a class="header-anchor" href="#其他语言版本" aria-hidden="true">#</a> 其他语言版本</h2><h3 id="python" tabindex="-1"><a class="header-anchor" href="#python" aria-hidden="true">#</a> Python</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> collections <span class="token keyword">import</span> deque

<span class="token builtin">dir</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token comment"># 创建方向元素</span>

<span class="token keyword">def</span> <span class="token function">bfs</span><span class="token punctuation">(</span>grid<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>
  
  queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 初始化队列</span>
  queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 放入第一个元素/起点</span>
  visited<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token comment"># 标记为访问过的节点</span>
  
  <span class="token keyword">while</span> queue<span class="token punctuation">:</span> <span class="token comment"># 遍历队列里的元素</span>
  
    curx<span class="token punctuation">,</span> cury <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 取出第一个元素</span>
    
    <span class="token keyword">for</span> dx<span class="token punctuation">,</span> dy <span class="token keyword">in</span> <span class="token builtin">dir</span><span class="token punctuation">:</span> <span class="token comment"># 遍历四个方向</span>
    
      nextx<span class="token punctuation">,</span> nexty <span class="token operator">=</span> curx <span class="token operator">+</span> dx<span class="token punctuation">,</span> cury <span class="token operator">+</span> dy
      
      <span class="token keyword">if</span> nextx <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> nextx <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">)</span> <span class="token keyword">or</span> nexty <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token keyword">or</span> nexty <span class="token operator">&gt;=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment"># 越界了，直接跳过</span>
        <span class="token keyword">continue</span>
        
      <span class="token keyword">if</span> <span class="token keyword">not</span> visited<span class="token punctuation">[</span>nextx<span class="token punctuation">]</span><span class="token punctuation">[</span>nexty<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment"># 如果节点没被访问过  </span>
        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>nextx<span class="token punctuation">,</span> nexty<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 加入队列</span>
        visited<span class="token punctuation">[</span>nextx<span class="token punctuation">]</span><span class="token punctuation">[</span>nexty<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span> <span class="token comment"># 标记为访问过的节点</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5);function f(_,E){const a=i("ExternalLinkIcon");return o(),c("div",null,[u,s("p",null,[n("在"),s("a",r,[n("深度优先搜索"),e(a)]),n("的讲解中，我们就讲过深度优先搜索和广度优先搜索的区别。")]),d,s("p",null,[n("以上模板代码，就是可以直接拿来做 "),s("a",k,[n("200.岛屿数量"),e(a)]),n(" 这道题目，唯一区别是 针对地图 grid 中有数字1的地方去做一个遍历。")]),v,s("p",null,[n("就可以通过 "),s("a",m,[n("200.岛屿数量"),e(a)]),n(" 这道题目，大家可以去体验一下。")]),b,h,x,s("p",null,[n("其实在二叉树章节的"),s("a",g,[n("层序遍历"),e(a)]),n("中，我们也讲过一次广搜，相当于是广搜在二叉树这种数据结构上的应用。")]),y])}const q=p(l,[["render",f],["__file","tulunguangsoulilunjichu.html.vue"]]);export{q as default};
