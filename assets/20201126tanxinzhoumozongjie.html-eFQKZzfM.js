import{_ as o,r as s,o as a,c as i,a as e,b as n,d as t,e as l}from"./app-pMbPEaNl.js";const c={},d=e("h1",{id:"本周小结-贪心算法系列一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-贪心算法系列一","aria-hidden":"true"},"#"),n(" 本周小结！（贪心算法系列一）")],-1),h=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),n(" 周一")],-1),_={href:"https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"},p=l('<p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong></p><p>有没有啥套路呢？</p><p><strong>不好意思，贪心没套路，就刷题而言，如果感觉好像局部最优可以推出全局最优，然后想不到反例，那就试一试贪心吧！</strong></p><p>而严格的数据证明一般有如下两种：</p><ul><li>数学归纳法</li><li>反证法</li></ul><p>数学就不在讲解范围内了，感兴趣的同学可以自己去查一查资料。</p><p>正是因为贪心算法有时候会感觉这是常识，本就应该这么做！ 所以大家经常看到网上有人说这是一道贪心题目，有人说这不是。</p><p>这里说一下我的依据：<strong>如果找到局部最优，然后推出整体最优，那么就是贪心</strong>，大家可以参考哈。</p><h2 id="周二" tabindex="-1"><a class="header-anchor" href="#周二" aria-hidden="true">#</a> 周二</h2>',9),u={href:"https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",target:"_blank",rel:"noopener noreferrer"},m=e("p",null,"这道题目很明显能看出来是用贪心，也是入门好题。",-1),E=e("p",null,[n("我在文中给出"),e("strong",null,"局部最优：大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优：喂饱尽可能多的小孩"),n("。")],-1),g=e("p",null,"很多录友都是用小饼干优先先喂饱小胃口的。",-1),v=e("p",null,"后来我想一想，虽然结果是一样的，但是大家的这个思考方式更好一些。",-1),b=e("p",null,[e("strong",null,"因为用小饼干优先喂饱小胃口的 这样可以尽量保证最后省下来的是大饼干（虽然题目没有这个要求）！")],-1),f=e("p",null,"所以还是小饼干优先先喂饱小胃口更好一些，也比较直观。",-1),A={href:"https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",target:"_blank",rel:"noopener noreferrer"},B=e("p",null,"就是快排O(nlog n)，遍历O(n)，加一起就是还是O(nlogn)。",-1),x=e("h2",{id:"周三",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周三","aria-hidden":"true"},"#"),n(" 周三")],-1),k=e("p",null,"接下来就要上一点难度了，要不然大家会误以为贪心算法就是常识判断一下就行了。",-1),F={href:"https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"},C=e("p",null,"其实就是让序列有尽可能多的局部峰值。",-1),N=e("p",null,"局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。",-1),z=e("p",null,"整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。",-1),I=e("p",null,"在计算峰值的时候，还是有一些代码技巧的，例如序列两端的峰值如何处理。",-1),V=e("p",null,"这些技巧，其实还是要多看多用才会掌握。",-1),D=e("h2",{id:"周四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周四","aria-hidden":"true"},"#"),n(" 周四")],-1),O={href:"https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"},S=e("p",null,[e("strong",null,"贪心的思路为局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。从而推出全局最优：选取最大“连续和”")],-1),j=e("p",null,"代码很简单，但是思路却比较难。还需要反复琢磨。",-1),L={href:"https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"},T=l(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int result = INT32_MIN;
        int count = 0;
        for (int i = 0; i &lt; nums.size(); i++) {
            count += nums[i];
            if (count &gt; result) { // 取区间累计的最大值（相当于不断确定最大子序终止位置）
                result = count;
            }
            if (count &lt;= 0) count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和
        }
        return result;
    }
};
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不少同学都来问，如果数组全是负数这个代码就有问题了，如果数组里有int最小值这个代码就有问题了。</p><p>大家不要脑洞模拟哈，可以亲自构造一些测试数据试一试，就发现其实没有问题。</p><p>数组都为负数，result记录的就是最大的负数，如果数组里有int最小值，那么最终result就是int最小值。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>`,5),y={href:"https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html",target:"_blank",rel:"noopener noreferrer"},M={href:"https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html",target:"_blank",rel:"noopener noreferrer"},q=e("p",null,"其实我还准备一些简单的贪心题目，甚至网上很多都质疑这些题目是不是贪心算法。这些题目我没有立刻发出来，因为真的会让大家感觉贪心过于简单，而忽略了贪心的本质：局部最优和全局最优两个关键点。",-1),w=e("p",null,[e("strong",null,"所以我在贪心系列难度会有所交替，难的题目在于拓展思路，简单的题目在于分析清楚其贪心的本质，后续我还会发一些简单的题目来做贪心的分析。")],-1),G={href:"https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"},H={href:"https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html",target:"_blank",rel:"noopener noreferrer"},J=e("strong",null,"不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数",-1);function K(P,Q){const r=s("ExternalLinkIcon");return a(),i("div",null,[d,h,e("p",null,[n("本周正式开始了贪心算法，在"),e("a",_,[n("关于贪心算法，你该了解这些！"),t(r)]),n("中，我们介绍了什么是贪心以及贪心的套路。")]),p,e("p",null,[n("在"),e("a",u,[n("贪心算法：分发饼干"),t(r)]),n("中讲解了贪心算法的第一道题目。")]),m,E,g,v,b,f,e("p",null,[n("一些录友不清楚"),e("a",A,[n("贪心算法：分发饼干"),t(r)]),n("中时间复杂度是怎么来的？")]),B,x,k,e("p",null,[n("在"),e("a",F,[n("贪心算法：摆动序列"),t(r)]),n("中，需要计算最长摇摆序列。")]),C,N,z,I,V,D,e("p",null,[n("在"),e("a",O,[n("贪心算法：最大子序和"),t(r)]),n("中，详细讲解了用贪心的方式来求最大子序列和，其实这道题目是一道动态规划的题目。")]),S,j,e("p",null,[n("针对"),e("a",L,[n("贪心算法：最大子序和"),t(r)]),n("文章中给出的贪心代码如下；")]),T,e("p",null,[n("本周我们讲解了"),e("a",y,[n("贪心算法的理论基础"),t(r)]),n("，了解了贪心本质：局部最优推出全局最优。")]),e("p",null,[n("然后讲解了第一道题目"),e("a",M,[n("分发饼干"),t(r)]),n("，还是比较基础的，可能会给大家一种贪心算法比较简单的错觉，因为贪心有时候接近于常识。")]),q,w,e("p",null,[n("在"),e("a",G,[n("摆动序列"),t(r)]),n("中大家就初步感受到贪心没那么简单了。")]),e("p",null,[n("本周最后是"),e("a",H,[n("最大子序和"),t(r)]),n("，这道题目要用贪心的方式做出来，就比较有难度，都知道负数加上正数之后会变小，但是这道题目依然会让很多人搞混淆，其关键在于："),J,n("。这块真的需要仔细体会！")])])}const U=o(c,[["render",K],["__file","20201126tanxinzhoumozongjie.html.vue"]]);export{U as default};
