import{_ as e,o as i,c as a,e as c}from"./app-pMbPEaNl.js";const l={},d=c('<h2 id="代码风格" tabindex="-1"><a class="header-anchor" href="#代码风格" aria-hidden="true">#</a> 代码风格</h2><ul><li><code>不甚了解</code>是不能更了解的意思，这个地方应该使用存疑。</li><li><code>后期在不断优化</code>，&#39;在&#39;应为&#39;再&#39;。</li><li><code>googlec++编程规范</code>,Google拼写错误</li></ul><h2 id="代码本地编译" tabindex="-1"><a class="header-anchor" href="#代码本地编译" aria-hidden="true">#</a> 代码本地编译</h2><ul><li><code>粘到本例来运行</code>存疑，应为本地</li><li><code>本题运行</code>存疑，应为本地</li></ul><h2 id="acm二叉树" tabindex="-1"><a class="header-anchor" href="#acm二叉树" aria-hidden="true">#</a> ACM二叉树</h2><ul><li><p>左孩子和右孩子的下标不太好理解。我给出证明过程：</p><p>如果父节点在第k层，第$m,m \\in [0,2^k]$个节点，则其左孩子所在的位置必然为$k+1$层，第$2*(m-1)+1$个节点。</p><ul><li><p>计算父节点在数组中的索引： $$ index_{father}=(\\sum_{i=0}^{i=k-1}2^i)+m-1=2^k-1+m-1 $$</p></li><li><p>计算左子节点在数组的索引： $$ index_{left}=(\\sum_{i=0}^{i=k}2^i)+2*m-1-1=2^{k+1}+2m-3 $$</p></li><li><p>故左孩子的下表为$index_{left}=index_{father}\\times2+1$，同理可得到右子孩子的索引关系。也可以直接在左子孩子的基础上<code>+1</code>。</p></li></ul></li></ul>',6),o=[d];function n(t,h){return i(),a("div",null,o)}const u=e(l,[["render",n],["__file","bianchengsuyangbufendechuimaoqiuci.html.vue"]]);export{u as default};
