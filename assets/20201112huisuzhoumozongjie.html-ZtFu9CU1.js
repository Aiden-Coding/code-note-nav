import{_ as o,r as l,o as a,c as s,a as e,b as r,d as t,e as h}from"./app-pMbPEaNl.js";const c={},i=e("h1",{id:"本周小结-回溯算法系列三",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#本周小结-回溯算法系列三","aria-hidden":"true"},"#"),r(" 本周小结！（回溯算法系列三）")],-1),p=e("h2",{id:"周一",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周一","aria-hidden":"true"},"#"),r(" 周一")],-1),d={href:"https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html",target:"_blank",rel:"noopener noreferrer"},u=e("p",null,"所以本题对大家应该并不难。",-1),g=e("p",null,"树形结构如下：",-1),E=e("p",null,[e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/2020111217110449-20230310133150714.png",alt:"90.子集II"})],-1),f=e("h2",{id:"周二",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周二","aria-hidden":"true"},"#"),r(" 周二")],-1),$={href:"https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"},k=e("p",null,[r("树形结构如下： "),e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201112170832333-20230310133155209.png",alt:"491. 递增子序列1"})],-1),I={href:"https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html",target:"_blank",rel:"noopener noreferrer"},A={href:"https://mp.weixin.qq.com/s/kSMGHc_YpsqL2j-jb_E_Ag",target:"_blank",rel:"noopener noreferrer"},x=e("h2",{id:"周三",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周三","aria-hidden":"true"},"#"),r(" 周三")],-1),B={href:"https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"},O=e("p",null,"排列是有序的，也就是说[1,2] 和[2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方。",-1),q=e("p",null,"可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。",-1),D=e("p",null,[r("如图： "),e("img",{src:"https://code-thinking-1253855093.file.myqcloud.com/pics/20201112170304979-20230310133201250.png",alt:"46.全排列"})],-1),y=e("p",null,[e("strong",null,"大家此时可以感受出排列问题的不同：")],-1),j=e("ul",null,[e("li",null,"每层都是从0开始搜索而不是startIndex"),e("li",null,"需要used数组记录path里都放了哪些元素了")],-1),z=e("h2",{id:"周四",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#周四","aria-hidden":"true"},"#"),r(" 周四")],-1),N={href:"https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html",target:"_blank",rel:"noopener noreferrer"},V=h('<p>树形结构如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201112171930470-20230310133206398.png" alt="47.全排列II1"></p><p><strong>这道题目神奇的地方就是used[i - 1] == false也可以，used[i - 1] == true也可以！</strong></p><p>我就用输入: [1,1,1] 来举一个例子。</p><p>树层上去重(used[i - 1] == false)，的树形结构如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201112172230434-20230310133211392.png" alt="47.全排列II2.png"></p><p>树枝上去重（used[i - 1] == true）的树型结构如下：</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201112172327967-20230310133216389.png" alt="47.全排列II3"></p><p><strong>可以清晰的看到使用(used[i - 1] == false)，即树层去重，效率更高！</strong></p><h2 id="性能分析" tabindex="-1"><a class="header-anchor" href="#性能分析" aria-hidden="true">#</a> 性能分析</h2><p>之前并没有分析各个问题的时间复杂度和空间复杂度，这次来说一说。</p><p>这块网上的资料鱼龙混杂，一些所谓的经典面试书籍根本不讲回溯算法，算法书籍对这块也避而不谈，感觉就像是算法里模糊的边界。</p><p><strong>所以这块就说一说我个人理解，对内容持开放态度，集思广益，欢迎大家来讨论！</strong></p><p>子集问题分析：</p><ul><li>时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。</li><li>空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。每个叶子节点都会有一个构造全排列填进数组的操作（对应的代码：<code>result.push_back(path)</code>），该操作的复杂度为$O(n)$。所以，最终时间复杂度为：n * n!，简化为$O(n!)$。</li><li>空间复杂度：$O(n)$，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：$O(n)$，和子集问题同理。</li></ul><p><strong>一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！</strong></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2>',21),v={href:"https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html",target:"_blank",rel:"noopener noreferrer"},F={href:"https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"},L={href:"https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html",target:"_blank",rel:"noopener noreferrer"},C={href:"https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html",target:"_blank",rel:"noopener noreferrer"},S=e("p",null,"最后我补充了子集问题，排列问题和组合问题的性能分析，给大家提供了回溯算法复杂度的分析思路。",-1);function w(G,H){const n=l("ExternalLinkIcon");return a(),s("div",null,[i,p,e("p",null,[r("在"),e("a",d,[r("回溯算法：求子集问题（二）"),t(n)]),r("中，开始针对子集问题进行去重。")]),e("p",null,[r("本题就是"),e("a",_,[r("回溯算法：求子集问题！"),t(n)]),r("的基础上加上了去重，去重我们在"),e("a",m,[r("回溯算法：求组合总和（三）"),t(n)]),r("也讲过了。")]),u,g,E,f,e("p",null,[r("在"),e("a",$,[r("回溯算法：递增子序列"),t(n)]),r("中，处处都能看到子集的身影，但处处是陷阱，值得好好琢磨琢磨！")]),k,e("p",null,[e("a",I,[r("回溯算法：递增子序列"),t(n)]),r("留言区大家有很多疑问，主要还是和"),e("a",b,[r("回溯算法：求子集问题（二）"),t(n)]),r("混合在了一起。")]),e("p",null,[r("详细在"),e("a",A,[r("本周小结！（回溯算法系列三）续集"),t(n)]),r("中给出了介绍！")]),x,e("p",null,[r("我们已经分析了组合问题，分割问题，子集问题，那么"),e("a",B,[r("回溯算法：排列问题！"),t(n)]),r(" 又不一样了。")]),O,q,D,y,j,z,e("p",null,[r("排列问题也要去重了，在"),e("a",N,[r("回溯算法：排列问题（二）"),t(n)]),r("中又一次强调了“树层去重”和“树枝去重”。")]),V,e("p",null,[r("本周我们对"),e("a",v,[r("子集问题进行了去重"),t(n)]),r("，然后介绍了和子集问题非常像的"),e("a",F,[r("递增子序列"),t(n)]),r("，如果还保持惯性思维，这道题就可以掉坑里。")]),e("p",null,[r("接着介绍了"),e("a",L,[r("排列问题！"),t(n)]),r("，以及对"),e("a",C,[r("排列问题如何进行去重"),t(n)]),r("。")]),S])}const T=o(c,[["render",w],["__file","20201112huisuzhoumozongjie.html.vue"]]);export{T as default};
